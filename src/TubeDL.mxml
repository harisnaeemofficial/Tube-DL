<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009"
					   xmlns:s="library://ns.adobe.com/flex/spark"
					   xmlns:mx="library://ns.adobe.com/flex/mx"
					   xmlns:fs="flatspark.components.*"
					   creationComplete="onCreationComplete(event)"
					   applicationActivate="onActivate(event)" xmlns:ns="http://flex.apache.org/experimental/ns"
					   >
	
	<fx:Style source="assets/css/FlatSpark.css"/>
	<fx:Script>
		<![CDATA[
			import flatspark.enums.BrandColorEnum;
			import flatspark.enums.ButtonSizeEnum;
			import flatspark.utils.AwesomeUtils;
			import flatspark.utils.ColorUtils;
			
			import mx.events.AIREvent;
			import mx.events.CloseEvent;
			import mx.events.FlexEvent;
			import mx.utils.StringUtil;
			
			import spark.components.Alert;
			
			private var process:NativeProcess;
			private var executable:File;
			private var ffmpegExePath:String;
			private var outputName:String = '';
			
			[Bindable]
			private var processStatus:int = 0;
			
			public const STATUS_DONE:int = 0;
			public const STATUS_DOWNLOADING:int = 1;
			public const STATUS_CONVERTING:int = 2;
			
			
			public function onCreationComplete(event:FlexEvent):void
			{
				this.process = new NativeProcess();
				process.addEventListener(ProgressEvent.STANDARD_OUTPUT_DATA, onOutputData);
				process.addEventListener(ProgressEvent.STANDARD_ERROR_DATA, onErrorData);
				process.addEventListener(NativeProcessExitEvent.EXIT, onExit);
				process.addEventListener(IOErrorEvent.STANDARD_OUTPUT_IO_ERROR, onIOError);
				process.addEventListener(IOErrorEvent.STANDARD_ERROR_IO_ERROR, onIOError);
				
				var exeName:String = this.isWindows ? 'youtube-dl.exe' : 'youtube-dl';
				var exePath:String = this.isWindows ? 'assets\\bin\\win\\' : 'assets/bin/osx/';
				
				this.ffmpegExePath = File.applicationDirectory.resolvePath(exePath).nativePath 
					+ File.separator + (this.isWindows ? 'ffmpeg.exe' : 'ffmpeg');
				this.executable = File.applicationDirectory.resolvePath(exePath + exeName);
				
			}
			
			public function onActivate(event:AIREvent):void
			{
				this.checkClipboard();
			}
			
			private function checkClipboard():void
			{
				var url:String = Clipboard.generalClipboard.getData(ClipboardFormats.URL_FORMAT) as String;
				
				if (url && url != urlTxt.text) {
					Alert.show('A URL was detected in your clipboard. Would you like to use it?',
						'URL Detected',
						Alert.YES|Alert.NO,
						null,
						function(evt:CloseEvent):void {
							if (evt.detail == Alert.YES) {
								urlTxt.text = url.split("\n")[0];
								clearResult();
							}
						}
					);
				}
				
			}
			
			private function get isWindows():Boolean
			{
				return Capabilities.os.toLowerCase().indexOf("win") > -1;
			}
			
			public function runNativeProcess( args:Array ):void
			{
				var arguments:Vector.<String> = new Vector.<String>();
				for each( var arg:String in args ) arguments.push(arg);
				
				var startupInfo:NativeProcessStartupInfo = new NativeProcessStartupInfo();
				startupInfo.executable = this.executable;
				startupInfo.arguments = arguments;
				startupInfo.workingDirectory = File.desktopDirectory;
				
				this.process.start(startupInfo);
				this.processStatus = STATUS_DOWNLOADING;
			}
			
			private function onOutputData(event:ProgressEvent):void
			{
				var output:String = StringUtil.trim( this.process.standardOutput.readUTFBytes(process.standardOutput.bytesAvailable) );
				showResult(output);
				
				// the output buffer may contain more than one line, and some are delimited
				// with \n and others \r, so we need to normalize, then split them in order
				// to go through the lines and parse them for information that we want
				var lines:Array = output.replace(/\r/g,'\n').split('\n');
				
				// the destination file line is in the format:
				// [download] Destination: filename.mp4
				// or if an audio conversion:
				// [ffmpeg] Destination: file.mp3
				// or if already downloaded:
				// [download] filename.mp4 has already been downloaded
				for each (var line:String in lines) {
					if (line.indexOf('[download] Destination:') > -1) {
						this.outputName = StringUtil.trim(line.substr(24));
					}
					
					if (line.indexOf('[ffmpeg] Destination:') > -1) {
						this.outputName = StringUtil.trim(line.substr(22));
						this.processStatus = STATUS_CONVERTING;
					}
					
					if (line.indexOf('[ffmpeg] Merging formats into ') > -1) {
						this.outputName = StringUtil.trim( line.substr(31,line.length-32) );
						this.processStatus = STATUS_CONVERTING;
					}	
					
					if (line.indexOf('has already been downloaded') > -1) {
						this.outputName = StringUtil.trim(line.substr(11).replace(' has already been downloaded','').replace(' and merged','') );
					}
				}
				
				// lines with download info are in the format:
				// [download]  50.4% of 38.59MiB at  3.11MiB/s ETA 00:06
				var lastLine:String = lines.pop();
				
				if (lastLine.substr(0,10) == '[download]' && lastLine.indexOf('ETA') > -1) {
					var percent:String = StringUtil.trim(lastLine.substr(10, lastLine.indexOf('%')-10));
					downloadProgress.currentProgress = parseFloat(percent);
				}
				
			}
			
			private function onErrorData(event:ProgressEvent):void
			{
				var output:String = this.process.standardError.readUTFBytes(process.standardError.bytesAvailable);
				showResult(output);
			}
			
			private function onExit(event:NativeProcessExitEvent):void
			{
				if (event.exitCode == 0) {
					showResult('File has been saved to your desktop.');
					
					openOutputFile();
					
				}
				else {
					showResult('Finished with errors.');
				}
				
				downloadProgress.currentProgress = 100;
				this.processStatus = STATUS_DONE;
			}
			
			private function onIOError(event:IOErrorEvent):void
			{
				showResult(event.text);
			}
			
			private function clearResult():void
			{
				this.outputName = '';
				resultTxt.text = '';
				downloadProgress.currentProgress = 0;
			}
			
			private function openOutputFile():void
			{
				if (this.outputName == '') {
					Alert.show('Unable to determine download file name','File Not Found');
					return;
				}
				
				var f:File = File.desktopDirectory.resolvePath(this.outputName);
				
				if (!f.exists) {
					Alert.show('The output file couldn\'t be found','File Not Found');
					return;
				}
				
				f.openWithDefaultApplication();
			}
			
			private function showResult(msg:String):void
			{
				resultTxt.appendText(StringUtil.trim(msg) + "\n");
				//				this.resultTxt.text += StringUtil.trim(msg) + "\n";
				//				this.resultTxt.scroller.verticalScrollBar.value = this.resultTxt.scroller.verticalScrollBar.maximum;
				//				this.resultTxt.validateNow();
			}
			
			protected function goBtn_clickHandler(event:MouseEvent):void
			{
				this.clearResult();
				this.showResult("Starting Download...");
				
				var args:Array = new Array(
					'--ignore-config',
					urlTxt.text
				);
				
				var format:String = outputFormatDD.selectedItem as String;
				if ('video' != format) {
					args.unshift(
						'--prefer-ffmpeg',
						'--ffmpeg-location=' + this.ffmpegExePath + '', 
						'--extract-audio',
						'--audio-format=' + format
					);
				}
				
				this.runNativeProcess(args);
			}
			
		]]>
	</fx:Script>
	
	<s:VGroup left="10" right="10" top="10" bottom="10" height="200" horizontalAlign="center">
		
		<s:HGroup width="100%" height="40">
			<!-- <s:Image source="assets/images/icon-40.png" width="40" height="40" /> -->
			<fs:TextInputIcon id="urlTxt" text="https://www.youtube.com/watch?v=aKkUhj5ryvE" width="100%" height="40" />
			<s:DropDownList id="outputFormatDD" height="40" selectedIndex="0">
				<s:ArrayCollection>
					<fx:String>video</fx:String>
					<fx:String>mp3</fx:String>
					<fx:String>vorbis</fx:String>
					<fx:String>wav</fx:String>
				</s:ArrayCollection>
			</s:DropDownList>
			<fs:ButtonIcon id="goBtn" label="Download" height="100%"
						   click="goBtn_clickHandler(event)" 
						   iconFont="{AwesomeUtils.fa_download}" 
						   brand="{BrandColorEnum.Info}"/>
		</s:HGroup>
		
		<ns:ProgressBar id="downloadProgress"
						visible="{processStatus == STATUS_DOWNLOADING}"
						includeInLayout="{processStatus == STATUS_DOWNLOADING}"
						width="100%" height="20" styleName="progressBar" 
						currentProgress="0" 
						totalProgress="100" 
						displayPercents="true"/>
		
		<mx:Box width="100%" paddingTop="6" paddingBottom="2"
				cornerRadius="4"
				visible="{processStatus == STATUS_CONVERTING}"
				includeInLayout="{processStatus == STATUS_CONVERTING}"
				backgroundColor="{ColorUtils.Amethyst}">
			<s:Label id="convertLabel"
					 text="Converting Audio..."
					 textAlign="center"
					 width="100%"
					 color="{ColorUtils.Clouds}"/>
		</mx:Box>
		
		<s:TextArea id="resultTxt"
					editable="false" width="100%" height="100%"/>
		
	</s:VGroup>
	
</s:WindowedApplication>